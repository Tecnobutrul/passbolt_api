#!/bin/bash

set -euo pipefail

# PARAPASSBOLTTEST AKA PARAPA (I'm loving it, yes, sorry about the reference)
#
# THIS SCRIPT IS EXPERIMENTAL
# Adjust test size to your CPU CORES.
# By default PHP version is 8
# Around 200 or 300 in 8 cpu machine takes 1 minute to run all tests.
# Test logs are stored in logfiles on the $LOG_PATH and showed to stdout at
# the end of the execution
#

TEST_GROUP_SIZE=200
DATABASE_DOCKER_IMAGE="mysql:5.7"
PHP_UNIT_DOCKER_IMAGE="registry.gitlab.com/passbolt/php-test-base-images:8.1"
PIDS=()
LOG_PATH="tmp/paratest"
PROGNAME="$0"

usage() {

  cat <<-EOF
  usage: $PROGNAME [OPTION] [ARGUMENTS]

  Always use this script from the root of the passbolt directory

  OPTIONS:

   -h this help message
   -d Relational database docker image (default mysql:5.7, intel)
   -p PHP base docker image (default php 8.1 image)
   -t test group size (# of tests per group, default 200)

  EXAMPLES:

   Default (only intel):
   -------------------------------------------
   bin/paratest

   Intel:
   -------------------------------------------
   bin/paratest -d "mysql:5.7" -p "registry.gitlab.com/passbolt/php-test-base-images:8.1"

   M1:
   -------------------------------------------
   bin/paratest -d "biarms/mysql" -p "registry.gitlab.com/passbolt/php-test-base-images/8.1-arm64:8.1"

EOF
}

get_options() {

  local OPTIND=$OPTIND

  while getopts "hd:p:t:" opt; do
    case $opt in
      d)
        DATABASE_DOCKER_IMAGE="$OPTARG"
        ;;
      p)
        PHP_UNIT_DOCKER_IMAGE="$OPTARG"
        ;;
      t)
        TEST_GROUP_SIZE="$OPTARG"
        ;;
      h)
        usage
        exit 0
        ;;
      *)
        echo "Invalid option"
        exit 1
        ;;
    esac
  done
}

cleanup_docker() {

  printf "Waiting for php containers to finish"
  while docker ps | grep passboltUnitTestGroup > /dev/null 2>&1; do
    printf "."
    sleep 1
  done
  printf "DONE! \n"

  EXIT_CODES=$(docker ps -a | grep passboltUnitTestGroup | awk '{print $1}' | xargs -I {} docker inspect {} --format='{{.State.ExitCode}}')

  for code in $EXIT_CODES; do
    if [[ $code != 0 ]]; then
      EXIT_STATUS=$code
      break
    fi
  done

  docker ps -a | grep phpunitDataSource | awk '{print $1}' | xargs docker kill
  docker ps -a | grep phpunitDataSource | awk '{print $1}' | xargs docker rm
  docker ps -a | grep passboltUnitTestGroup | awk '{print $1}' | xargs docker rm
}

calculate_test_groups() {

  docker run -i \
    --rm \
    --workdir='/app' \
    -v ${PWD}:/app \
    $PHP_UNIT_DOCKER_IMAGE \
    /bin/bash -c "
      vendor/bin/phpunit --bootstrap config/bootstrap.php --list-tests" | \
    awk -F '::' '{print $2}' | \
    awk NF | \
    awk -F '\"' '{print $1}' | \
    awk -F '#' '{print $1}' | \
    uniq | \
    awk '{print $1".*|"}' | \
    awk -v n=$TEST_GROUP_SIZE '1; NR % n == 0 {print ""}' | \
    awk '{ORS = sub(/\|$/,"|") ? "" : "\n"} 1' | \
    awk '{sub(/\|$/,"")}1' | \
    awk '{print "/"$1"/"}'
}

start_test_mysql() {

  local SERVER=$1
  local TEST_GROUP=$2
  local DATASOURCE_HOST=1.1.1.1

  docker run -d \
    --name phpunitDataSource$SERVER \
    --tmpfs /var/lib/mysql:rw \
    -e MYSQL_USER=test \
    -e MYSQL_PASSWORD=test \
    -e MYSQL_DATABASE=test \
    -e MYSQL_ROOT_PASSWORD=test \
    $DATABASE_DOCKER_IMAGE \
    bash -c "
      docker-entrypoint.sh mysqld \
        --default-authentication-plugin=mysql_native_password \
        --log-bin-trust-function-creators=1
    "

  DATASOURCE_HOST=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' phpunitDataSource$SERVER)

	RANDOM_DB_NAME=$(echo $RANDOM)
  docker run \
    -w=/app \
    --name passboltUnitTestGroup$SERVER \
    -v ${PWD}:/app \
    $PHP_UNIT_DOCKER_IMAGE bash -c "
      until mysqladmin -h $DATASOURCE_HOST -u root -ptest ping > /dev/null 2>&1; do
        sleep 1
      done
      mysqladmin -u root -h ${DATASOURCE_HOST} create test$RANDOM_DB_NAME -ptest && \
      gpg --import config/gpg/unsecure_private.key > /dev/null 2>&1 && \
      gpg --import config/gpg/unsecure.key > /dev/null 2>&1 && \
      DEBUG=1 \
      PASSBOLT_REGISTRATION_PUBLIC=1 \
      PASSBOLT_SELENIUM_ACTIVE=1 \
      APP_FULL_BASE_URL=http://127.0.0.1 \
      PASSBOLT_GPG_SERVER_KEY_PUBLIC=config/gpg/unsecure.key \
      PASSBOLT_GPG_SERVER_KEY_PRIVATE=config/gpg/unsecure_private.key \
      PASSBOLT_GPG_SERVER_KEY_FINGERPRINT=2FC8945833C51946E937F9FED47B0811573EE67E \
      DATASOURCES_TEST_DATABASE=test \
      DATASOURCES_TEST_USERNAME=root \
      DATASOURCES_TEST_PASSWORD=test \
      DATASOURCES_TEST_HOST=${DATASOURCE_HOST} \
      vendor/bin/phpunit --filter='${TEST_GROUP}'" > tmp/paratest/phpunit_test_log$SERVER.txt &

  until docker inspect -f '{{.State.Pid}}' passboltUnitTestGroup$SERVER > /dev/null 2>&1; do
    sleep 1
  done

  PIDS+=$(docker inspect -f '{{.State.Pid}}' passboltUnitTestGroup$SERVER)
}

start_test_postgres() {

  local SERVER=$1
  local TEST_GROUP=$2
  local DATASOURCE_HOST=1.1.1.1

  docker run -d \
    --name phpunitDataSource$SERVER \
    --tmpfs /var/lib/postgresql/data:rw \
    -e POSTGRES_USER=test \
    -e POSTGRES_PASSWORD=test \
    -e POSTGRES_HOST_AUTH_METHOD=trust \
    -e POSTGRES_DATABASE=test \
    $DATABASE_DOCKER_IMAGE

  DATASOURCE_HOST=$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' phpunitDataSource$SERVER)

	RANDOM_DB_NAME=$(echo $RANDOM)
  docker run \
    -w=/app \
    --name passboltUnitTestGroup$SERVER \
    -v ${PWD}:/app \
    $PHP_UNIT_DOCKER_IMAGE bash -c "
      until pg_isready --host=$DATASOURCE_HOST --port=5432 > /dev/null 2>&1; do
        sleep 1
      done
      psql -U test -h ${DATASOURCE_HOST} -c 'create database test$RANDOM_DB_NAME;' && \
      gpg --import config/gpg/unsecure_private.key > /dev/null 2>&1 && \
      gpg --import config/gpg/unsecure.key > /dev/null 2>&1 && \
      DEBUG=1 \
      PASSBOLT_REGISTRATION_PUBLIC=1 \
      PASSBOLT_SELENIUM_ACTIVE=1 \
      APP_FULL_BASE_URL=http://127.0.0.1 \
      PASSBOLT_GPG_SERVER_KEY_PUBLIC=config/gpg/unsecure.key \
      PASSBOLT_GPG_SERVER_KEY_PRIVATE=config/gpg/unsecure_private.key \
      PASSBOLT_GPG_SERVER_KEY_FINGERPRINT=2FC8945833C51946E937F9FED47B0811573EE67E \
      DATASOURCES_TEST_DATABASE=test \
      DATASOURCES_TEST_USERNAME=test \
      DATASOURCES_TEST_PASSWORD=test \
      DATASOURCES_TEST_DRIVER='Cake\Database\Driver\Postgres' \
      DATASOURCES_TEST_PORT=5432 \
      DATASOURCES_TEST_ENCODING=utf8 \
      DATASOURCES_TEST_HOST=${DATASOURCE_HOST} \
      vendor/bin/phpunit --filter='${TEST_GROUP}'" > tmp/paratest/phpunit_test_log$SERVER.txt &

  until docker inspect -f '{{.State.Pid}}' passboltUnitTestGroup$SERVER > /dev/null 2>&1; do
    sleep 1
  done

  PIDS+=$(docker inspect -f '{{.State.Pid}}' passboltUnitTestGroup$SERVER)
}

get_options "$@"

EXIT_STATUS=0
mkdir -p $LOG_PATH

if [[ "$DATABASE_DOCKER_IMAGE" == *"mysql"* ]] || [[ "$DATABASE_DOCKER_IMAGE" == *"mariadb"* ]] ; then
  # Start the tests in background
  COUNT=0
  for group in $(calculate_test_groups); do
    start_test_mysql $COUNT $group &
    COUNT=$(($COUNT +1))
  done
fi

if [[ "$DATABASE_DOCKER_IMAGE" == *"postgre"* ]]; then
  # Start the tests in background
  COUNT=0
  for group in $(calculate_test_groups); do
    start_test_postgres $COUNT $group &
    COUNT=$(($COUNT +1))
  done
fi

wait
# Clean docker containers
cleanup_docker

# Show test results in console
cat $LOG_PATH/phpunit_test_log*.txt

exit $EXIT_STATUS
